//! Version-specific MusicXML parsing and upgrade logic.
//!
//! Each supported MusicXML version has its own submodule (e.g. `v2_0`, `v4_0`) with
//! types generated from that version's XSD. Use [detect_musicxml_version] to determine
//! which version a document uses.

use std::borrow::Cow;

/// Supported MusicXML version labels (module names).
/// Versions 1.0 and 1.1 are DTD-only; 2.0–4.1 have XSD.
pub const MUSICXML_VERSION_LABELS: &[&str] = &["v2_0", "v3_0", "v3_1", "v4_0"];

/// Versioned import modules (generated by build.rs from each version's musicxml.xsd).
pub mod v2_0;
pub mod v3_0;
pub mod v3_1;
pub mod v4_0;

/// Detect MusicXML version from the root element of an XML document.
///
/// Looks for `@version` on `<score-partwise>` or `<score-timewise>`.
/// Returns a version label (e.g. `"4.0"` → `"v4_0"`), or `None` if unknown/missing.
pub fn detect_musicxml_version(xml: &str) -> Option<Cow<'static, str>> {
    let root = find_musicxml_root(xml)?;
    let version = get_version_attr(&root)?;
    version_string_to_label(version).map(Cow::Borrowed)
}

/// Map version string (e.g. "2.0", "4.0", "4.1") to versioned module label (e.g. "v2_0", "v4_0").
pub fn version_string_to_label(version: &str) -> Option<&'static str> {
    let v = version.trim();
    match v {
        "1.0" => Some("v1_0"), // DTD-only, no generated module yet
        "1.1" => Some("v1_1"),
        "2.0" => Some("v2_0"),
        "3.0" => Some("v3_0"),
        "3.1" => Some("v3_1"),
        "4.0" => Some("v4_0"),
        "4.1" => Some("v4_1"), // main schema, no separate versioned module
        _ => None,
    }
}

/// Return the first opening tag that is "score-partwise" or "score-timewise" (slice from '<' to '>' inclusive).
fn find_musicxml_root(xml: &str) -> Option<&str> {
    let bytes = xml.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        if bytes[i] == b'<' && i + 1 < bytes.len() && bytes[i + 1] != b'/' && bytes[i + 1] != b'!' {
            let tag_start = i;
            i += 1;
            while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t' || bytes[i] == b'\n') {
                i += 1;
            }
            let name_start = i;
            while i < bytes.len() && bytes[i] != b' ' && bytes[i] != b'\t' && bytes[i] != b'>' {
                i += 1;
            }
            let name_end = i;
            let name_slice = &bytes[name_start..name_end];
            let local = if let Some(colon) = name_slice.iter().position(|&b| b == b':') {
                &name_slice[colon + 1..]
            } else {
                name_slice
            };
            if local == b"score-partwise" || local == b"score-timewise" {
                while i < bytes.len() && bytes[i] != b'>' {
                    i += 1;
                }
                if i < bytes.len() {
                    return Some(&xml[tag_start..=i]);
                }
                return None;
            }
        }
        i += 1;
    }
    None
}

fn get_version_attr(root_tag: &str) -> Option<&str> {
    let bytes = root_tag.as_bytes();
    let mut i = 0;
    while i + 8 < bytes.len() {
        if bytes[i] == b'v' && bytes[i + 1..].starts_with(b"ersion") {
            i += 7;
            while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t') {
                i += 1;
            }
            if i < bytes.len() && bytes[i] == b'=' {
                i += 1;
                while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t') {
                    i += 1;
                }
                let quote = bytes.get(i)?;
                if *quote != b'"' && *quote != b'\'' {
                    return None;
                }
                i += 1;
                let value_start = i;
                while i < bytes.len() && bytes[i] != *quote {
                    i += 1;
                }
                let value_end = i;
                return std::str::from_utf8(&bytes[value_start..value_end]).ok();
            }
        }
        i += 1;
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn detect_version_from_partwise() {
        let xml = r#"<?xml version="1.0"?><score-partwise version="4.0">"#;
        assert_eq!(detect_musicxml_version(xml).as_deref(), Some("v4_0"));
    }

    #[test]
    fn detect_version_from_timewise() {
        let xml = r#"<score-timewise version="3.1">"#;
        assert_eq!(detect_musicxml_version(xml).as_deref(), Some("v3_1"));
    }

    #[test]
    fn version_string_to_label() {
        assert_eq!(version_string_to_label("4.0"), Some("v4_0"));
        assert_eq!(version_string_to_label("2.0"), Some("v2_0"));
        assert_eq!(version_string_to_label("4.1"), Some("v4_1"));
        assert_eq!(version_string_to_label(" 3.1 "), Some("v3_1"));
        assert_eq!(version_string_to_label("5.0"), None);
    }
}
