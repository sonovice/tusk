//! Version-specific MusicXML parsing and upgrade logic.
//!
//! Each supported MusicXML version has its own submodule (e.g. `v2_0`, `v4_0`) with
//! types generated from that version's XSD. Use [detect_musicxml_version] to determine
//! which version a document uses.

use std::borrow::Cow;

/// The version string our output always uses.
pub const OUTPUT_VERSION: &str = "4.1";

/// Supported MusicXML version labels (module names).
/// Versions 1.0 and 1.1 are DTD-only; 2.0–4.1 have XSD.
pub const MUSICXML_VERSION_LABELS: &[&str] = &["v2_0", "v3_0", "v3_1", "v4_0", "v4_1"];

/// Versioned import modules (generated by build.rs from each version's musicxml.xsd).
pub mod v2_0;
pub mod v3_0;
pub mod v3_1;
pub mod v4_0;
pub mod v4_1;

/// Detect MusicXML version from the root element of an XML document.
///
/// Looks for `@version` on `<score-partwise>` or `<score-timewise>`.
/// Returns a version label (e.g. `"4.0"` → `"v4_0"`), or `None` if unknown/missing.
pub fn detect_musicxml_version(xml: &str) -> Option<Cow<'static, str>> {
    let root = find_musicxml_root(xml)?;
    let version = get_version_attr(root)?;
    version_string_to_label(version).map(Cow::Borrowed)
}

/// Detect the raw version string from a MusicXML document.
///
/// Checks (in order):
/// 1. `@version` attribute on `<score-partwise>` / `<score-timewise>`
/// 2. DOCTYPE public identifier (e.g. "MusicXML 3.1 Partwise" → "3.1")
///
/// Returns `None` if neither source provides a recognized version.
pub fn detect_version_string(xml: &str) -> Option<&'static str> {
    // Try @version attribute first
    if let Some(root) = find_musicxml_root(xml) {
        if let Some(v) = get_version_attr(root) {
            return version_string_to_canonical(v);
        }
    }
    // Fall back to DOCTYPE
    detect_version_from_doctype(xml)
}

/// Map version string (e.g. "2.0", "4.0", "4.1") to versioned module label (e.g. "v2_0", "v4_0").
pub fn version_string_to_label(version: &str) -> Option<&'static str> {
    let v = version.trim();
    match v {
        "1.0" => Some("v1_0"), // DTD-only, no generated module yet
        "1.1" => Some("v1_1"),
        "2.0" => Some("v2_0"),
        "3.0" => Some("v3_0"),
        "3.1" => Some("v3_1"),
        "4.0" => Some("v4_0"),
        "4.1" => Some("v4_1"),
        _ => None,
    }
}

/// Map version string to a canonical static str (validates it is known).
fn version_string_to_canonical(version: &str) -> Option<&'static str> {
    let v = version.trim();
    match v {
        "1.0" => Some("1.0"),
        "1.1" => Some("1.1"),
        "2.0" => Some("2.0"),
        "3.0" => Some("3.0"),
        "3.1" => Some("3.1"),
        "4.0" => Some("4.0"),
        "4.1" => Some("4.1"),
        _ => None,
    }
}

/// Detect version from a DOCTYPE declaration.
///
/// MusicXML DOCTYPEs contain the version in the public identifier, e.g.:
/// `<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" ...>`
fn detect_version_from_doctype(xml: &str) -> Option<&'static str> {
    // Find DOCTYPE declaration (case-insensitive)
    let upper = xml.to_ascii_uppercase();
    let dt_start = upper.find("<!DOCTYPE")?;
    // Find the end of the DOCTYPE
    let dt_end = xml[dt_start..].find('>')? + dt_start;
    let doctype = &xml[dt_start..=dt_end];

    // Look for "MusicXML X.Y" in the public ID
    let upper_dt = doctype.to_ascii_uppercase();
    let mxml_pos = upper_dt.find("MUSICXML ")?;
    let after = &doctype[mxml_pos + 9..]; // skip "MusicXML "
    // Extract version: digits, dot, digits
    let ver_end = after
        .find(|c: char| !c.is_ascii_digit() && c != '.')
        .unwrap_or(after.len());
    let ver_str = &after[..ver_end];
    version_string_to_canonical(ver_str)
}

/// Return the first opening tag that is "score-partwise" or "score-timewise" (slice from '<' to '>' inclusive).
fn find_musicxml_root(xml: &str) -> Option<&str> {
    let bytes = xml.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        if bytes[i] == b'<' && i + 1 < bytes.len() && bytes[i + 1] != b'/' && bytes[i + 1] != b'!' {
            let tag_start = i;
            i += 1;
            while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t' || bytes[i] == b'\n') {
                i += 1;
            }
            let name_start = i;
            while i < bytes.len() && bytes[i] != b' ' && bytes[i] != b'\t' && bytes[i] != b'>' {
                i += 1;
            }
            let name_end = i;
            let name_slice = &bytes[name_start..name_end];
            let local = if let Some(colon) = name_slice.iter().position(|&b| b == b':') {
                &name_slice[colon + 1..]
            } else {
                name_slice
            };
            if local == b"score-partwise" || local == b"score-timewise" {
                while i < bytes.len() && bytes[i] != b'>' {
                    i += 1;
                }
                if i < bytes.len() {
                    return Some(&xml[tag_start..=i]);
                }
                return None;
            }
        }
        i += 1;
    }
    None
}

fn get_version_attr(root_tag: &str) -> Option<&str> {
    let bytes = root_tag.as_bytes();
    let mut i = 0;
    while i + 8 < bytes.len() {
        if bytes[i] == b'v' && bytes[i + 1..].starts_with(b"ersion") {
            i += 7;
            while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t') {
                i += 1;
            }
            if i < bytes.len() && bytes[i] == b'=' {
                i += 1;
                while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t') {
                    i += 1;
                }
                let quote = bytes.get(i)?;
                if *quote != b'"' && *quote != b'\'' {
                    return None;
                }
                i += 1;
                let value_start = i;
                while i < bytes.len() && bytes[i] != *quote {
                    i += 1;
                }
                let value_end = i;
                return std::str::from_utf8(&bytes[value_start..value_end]).ok();
            }
        }
        i += 1;
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn detect_version_from_partwise() {
        let xml = r#"<?xml version="1.0"?><score-partwise version="4.0">"#;
        assert_eq!(detect_musicxml_version(xml).as_deref(), Some("v4_0"));
    }

    #[test]
    fn detect_version_from_timewise() {
        let xml = r#"<score-timewise version="3.1">"#;
        assert_eq!(detect_musicxml_version(xml).as_deref(), Some("v3_1"));
    }

    #[test]
    fn test_version_string_to_label() {
        assert_eq!(version_string_to_label("4.0"), Some("v4_0"));
        assert_eq!(version_string_to_label("2.0"), Some("v2_0"));
        assert_eq!(version_string_to_label("4.1"), Some("v4_1"));
        assert_eq!(version_string_to_label(" 3.1 "), Some("v3_1"));
        assert_eq!(version_string_to_label("5.0"), None);
    }

    #[test]
    fn detect_version_string_from_attr() {
        let xml = r#"<?xml version="1.0"?><score-partwise version="3.1">"#;
        assert_eq!(detect_version_string(xml), Some("3.1"));
    }

    #[test]
    fn detect_version_string_from_doctype() {
        let xml = r#"<?xml version="1.0"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise>"#;
        assert_eq!(detect_version_string(xml), Some("3.1"));
    }

    #[test]
    fn detect_version_string_doctype_2_0() {
        let xml = r#"<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 2.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise>"#;
        assert_eq!(detect_version_string(xml), Some("2.0"));
    }

    #[test]
    fn detect_version_attr_takes_priority_over_doctype() {
        let xml = r#"<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="4.0">"#;
        assert_eq!(detect_version_string(xml), Some("4.0"));
    }

    #[test]
    fn detect_version_string_unknown() {
        let xml = r#"<score-partwise version="99.0">"#;
        assert_eq!(detect_version_string(xml), None);
    }

    #[test]
    fn detect_version_string_no_version() {
        // MusicXML 1.0 files may lack version attribute entirely
        let xml = r#"<score-partwise>"#;
        assert_eq!(detect_version_string(xml), None);
    }
}
