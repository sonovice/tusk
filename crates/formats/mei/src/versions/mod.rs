//! Version-specific MEI parsing and migration logic.
//!
//! Each supported MEI version has its own submodule (e.g. `v2_1_1`, `v5_1`) with
//! types generated from that version's RNG. Use [detect_mei_version] to determine
//! which version a document uses; migration from versioned types to the internal
//! MEI 6.0-dev model is a separate step.

use std::borrow::Cow;

/// Supported MEI version labels (module names and RNG version suffixes).
pub const MEI_VERSION_LABELS: &[&str] = &["v2_1_1", "v3_0_0", "v4_0_1", "v5_0", "v5_1", "v6_0_dev"];

/// Versioned import modules (generated by build.rs from MEI RNG specs).
pub mod v2_1_1;
pub mod v3_0_0;
pub mod v4_0_1;
pub mod v5_0;
pub mod v5_1;
pub mod v6_0_dev;

pub mod convert;

pub use convert::{
    ConversionError, DEFAULT_EXPORT_VERSION, VersionedMei, from_internal, to_internal,
};

/// Detect MEI version from the root element of an XML document.
///
/// Looks for `@meiversion` or `@version` on the root `<mei>` (or namespace-qualified)
/// element. Returns a version label suitable for choosing a versioned module
/// (e.g. `"2.1.1"` â†’ `"v2_1_1"`), or `None` if unknown/missing.
pub fn detect_mei_version(xml: &str) -> Option<Cow<'static, str>> {
    let root = find_mei_root(xml)?;
    let version = get_attribute(&root, "meiversion").or_else(|| get_attribute(&root, "version"))?;
    version_string_to_label(version).map(Cow::Borrowed)
}

/// Map version string (e.g. "2.1.1", "5.1", "6.0") to versioned module label (e.g. "v2_1_1", "v5_1", "v6_0_dev").
pub fn version_string_to_label(version: &str) -> Option<&'static str> {
    let v = version.trim();
    match v {
        "2.1.1" => Some("v2_1_1"),
        "3.0.0" => Some("v3_0_0"),
        "4.0.1" => Some("v4_0_1"),
        "5.0" | "5.0.0" => Some("v5_0"),
        "5.1" | "5.1.0" => Some("v5_1"),
        "6.0" | "6.0.0" | "6.0-dev" => Some("v6_0_dev"),
        _ => None,
    }
}

/// Return the first opening tag whose local name is "mei" (slice from '<' to '>' inclusive).
fn find_mei_root(xml: &str) -> Option<&str> {
    let bytes = xml.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        if bytes[i] == b'<' && i + 1 < bytes.len() && bytes[i + 1] != b'/' && bytes[i + 1] != b'!' {
            let tag_start = i;
            i += 1;
            while i < bytes.len() && (bytes[i] == b' ' || bytes[i] == b'\t' || bytes[i] == b'\n') {
                i += 1;
            }
            let name_start = i;
            while i < bytes.len() && bytes[i] != b' ' && bytes[i] != b'\t' && bytes[i] != b'>' {
                i += 1;
            }
            let name_end = i;
            let name_slice = &bytes[name_start..name_end];
            let local = if let Some(colon) = name_slice.iter().position(|&b| b == b':') {
                &name_slice[colon + 1..]
            } else {
                name_slice
            };
            if local == b"mei" {
                while i < bytes.len() && bytes[i] != b'>' {
                    i += 1;
                }
                if i < bytes.len() {
                    return Some(&xml[tag_start..=i]);
                }
                return None;
            }
        }
        i += 1;
    }
    None
}

/// Get attribute value from a tag slice (from '<' to '>'). Supports attr="value" and attr='value'.
fn get_attribute<'a>(tag: &'a str, name: &str) -> Option<&'a str> {
    let bytes = tag.as_bytes();
    let name_bytes = name.as_bytes();
    let mut i = 0;
    while i + name_bytes.len() < bytes.len() && bytes[i] != b'>' {
        let ok_start = i == 0 || bytes[i - 1] == b' ' || bytes[i - 1] == b'\t';
        if ok_start && bytes[i..].starts_with(name_bytes) {
            let j = i + name_bytes.len();
            let mut k = j;
            while k < bytes.len() && (bytes[k] == b' ' || bytes[k] == b'\t') {
                k += 1;
            }
            if k < bytes.len() && bytes[k] == b'=' {
                k += 1;
                while k < bytes.len() && (bytes[k] == b' ' || bytes[k] == b'\t') {
                    k += 1;
                }
                if k < bytes.len() {
                    let quote = bytes[k];
                    if quote == b'"' || quote == b'\'' {
                        let start = k + 1;
                        let mut end = start;
                        while end < bytes.len() && bytes[end] != quote {
                            end += 1;
                        }
                        if end <= bytes.len() {
                            return Some(std::str::from_utf8(&bytes[start..end]).unwrap_or(""));
                        }
                    }
                }
            }
        }
        i += 1;
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn detect_mei_version_meiversion() {
        let xml = r#"<?xml version="1.0"?><mei xmlns="http://www.music-encoding.org/ns/mei" meiversion="5.1">"#;
        assert_eq!(detect_mei_version(xml).as_deref(), Some("v5_1"));
    }

    #[test]
    fn detect_mei_version_version_attr() {
        let xml = r#"<mei version="2.1.1">"#;
        assert_eq!(detect_mei_version(xml).as_deref(), Some("v2_1_1"));
    }

    #[test]
    fn test_version_string_to_label() {
        assert_eq!(version_string_to_label("5.1"), Some("v5_1"));
        assert_eq!(version_string_to_label("2.1.1"), Some("v2_1_1"));
        assert_eq!(version_string_to_label("5.0"), Some("v5_0"));
        assert_eq!(version_string_to_label("unknown"), None);
    }
}
