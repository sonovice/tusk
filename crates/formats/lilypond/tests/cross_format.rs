//! Cross-format roundtrip tests: LilyPond ↔ MusicXML via MEI.
//!
//! Tests the full pipeline: LilyPond → MEI → MusicXML (and back).
//! Many LilyPond files won't produce valid MusicXML (features don't all map),
//! so tests gracefully skip failures.
//!
//! Per-file regression tests are generated by build.rs and included at the bottom.

use std::path::{Path, PathBuf};

use tusk_format::{Exporter, Importer};
use tusk_lilypond::export::export as ly_export;
use tusk_lilypond::import::import as ly_import;
use tusk_lilypond::parser::Parser;
use tusk_lilypond::serializer;
use tusk_musicxml::MusicXmlFormat;

fn fixture_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../../tests/fixtures/lilypond")
}

fn regression_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../../specs/lilypond/repo/input/regression")
}

fn load_regression(name: &str) -> String {
    let path = regression_dir().join(name);
    std::fs::read_to_string(&path).unwrap_or_else(|e| panic!("read {}: {e}", path.display()))
}

fn sorted_ly_entries(dir: &Path) -> Vec<std::fs::DirEntry> {
    let mut entries: Vec<_> = std::fs::read_dir(dir)
        .expect("read dir")
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path()
                .extension()
                .and_then(|x| x.to_str())
                .is_some_and(|x| x == "ly")
        })
        .collect();
    entries.sort_by_key(|e| e.file_name());
    entries
}

/// Cross-format test: LilyPond → MEI → MusicXML, skips on any failure.
fn try_cross_format(src: &str, _name: &str) {
    let mxml = MusicXmlFormat;
    let Ok(file) = Parser::new(src).and_then(|p| p.parse()) else {
        return;
    };
    let Ok((mei, ext_store)) = ly_import(&file) else {
        return;
    };
    // Just assert no panic — if export fails, that's OK for now.
    let _ = mxml.export_to_string(&mei, &ext_store);
}

// ============================================================================
// Fixture sweep tests (tests/fixtures/lilypond/)
// ============================================================================

/// LilyPond → MEI → MusicXML for each fixture.
#[test]
fn cross_format_lilypond_to_musicxml() {
    let mxml = MusicXmlFormat;
    let dir = fixture_dir();
    let entries = sorted_ly_entries(&dir);
    let mut exported_mxml = 0u32;

    for entry in &entries {
        let src = std::fs::read_to_string(entry.path()).expect("read fixture");
        let Ok(file) = Parser::new(&src).and_then(|p| p.parse()) else {
            continue;
        };
        let Ok((mei, ext_store)) = ly_import(&file) else {
            continue;
        };
        if mxml.export_to_string(&mei, &ext_store).is_ok() {
            exported_mxml += 1;
        }
    }

    assert!(
        exported_mxml >= 10,
        "expected ≥10 successful MusicXML exports, got {exported_mxml}"
    );
}

/// LilyPond → MEI → MusicXML → MEI → MusicXML triangle stabilization.
#[test]
fn cross_format_triangle() {
    let mxml = MusicXmlFormat;
    let dir = fixture_dir();
    let entries = sorted_ly_entries(&dir);
    let mut passed = 0u32;

    for entry in &entries {
        let src = std::fs::read_to_string(entry.path()).expect("read fixture");
        let Ok(file1) = Parser::new(&src).and_then(|p| p.parse()) else {
            continue;
        };
        let Ok((mei1, ext1)) = ly_import(&file1) else {
            continue;
        };
        let Ok(mxml1) = mxml.export_to_string(&mei1, &ext1) else {
            continue;
        };
        let Ok((mei2, ext2)) = mxml.import_from_str(&mxml1) else {
            continue;
        };
        let Ok(mxml2) = mxml.export_to_string(&mei2, &ext2) else {
            continue;
        };
        if mxml1 == mxml2 {
            passed += 1;
        }
    }

    eprintln!("cross-format triangle: {passed} passed (of {} files)", entries.len());
}

/// Full cross-format roundtrip: LilyPond → MEI → MusicXML → MEI → LilyPond.
#[test]
fn cross_format_full_roundtrip() {
    let mxml = MusicXmlFormat;
    let dir = fixture_dir();
    let entries = sorted_ly_entries(&dir);
    let mut passed = 0u32;

    for entry in &entries {
        let src = std::fs::read_to_string(entry.path()).expect("read fixture");
        let Ok(file1) = Parser::new(&src).and_then(|p| p.parse()) else {
            continue;
        };
        let Ok((mei1, ext1)) = ly_import(&file1) else {
            continue;
        };
        let Ok(mxml_str) = mxml.export_to_string(&mei1, &ext1) else {
            continue;
        };
        let Ok((mei2, ext2)) = mxml.import_from_str(&mxml_str) else {
            continue;
        };
        let Ok(ly_file2) = ly_export(&mei2, &ext2) else {
            continue;
        };
        let _ly2 = serializer::serialize(&ly_file2);
        passed += 1;
    }

    eprintln!(
        "cross-format full roundtrip: {passed} completed (of {} files)",
        entries.len()
    );
}

// ============================================================================
// Per-file regression tests (generated by build.rs)
// ============================================================================

include!(concat!(env!("OUT_DIR"), "/regression_cross_format.rs"));
