//! Measure/part/score structure conversion from MusicXML to MEI.
//!
//! This module handles conversion of structural elements:
//! - `<body>` containing `<mdiv>`
//! - `<mdiv>` containing `<score>`
//! - `<score>` containing `<scoreDef>` and `<section>`
//! - `<section>` containing `<measure>`
//! - `<measure>` containing `<staff>` and control events
//! - `<staff>` containing `<layer>`
//! - `<layer>` containing notes, rests, chords

use crate::context::ConversionContext;
use crate::error::ConversionResult;
use crate::musicxml_to_mei::{
    DirectionConversionResult, convert_chord, convert_direction, convert_measure_rest,
    convert_note, convert_rest, convert_score_def, is_measure_rest,
};
use tusk_model::data::{DataBoolean, DataMeasurementunsigned, DataWord};
use tusk_model::elements::{
    Body, BodyChild, LayerChild, Mdiv, MdivChild, MeasureChild, Score, ScoreChild, Section,
    SectionChild, StaffChild,
};
use tusk_musicxml::model::elements::ScorePartwise;

/// Convert MusicXML content to MEI body.
pub fn convert_body(score: &ScorePartwise, ctx: &mut ConversionContext) -> ConversionResult<Body> {
    let mut body = Body::default();

    // Create mdiv containing the score
    let mdiv = convert_mdiv(score, ctx)?;
    body.children.push(BodyChild::Mdiv(Box::new(mdiv)));

    Ok(body)
}

/// Convert MusicXML score to MEI mdiv.
pub fn convert_mdiv(score: &ScorePartwise, ctx: &mut ConversionContext) -> ConversionResult<Mdiv> {
    let mut mdiv = Mdiv::default();

    // Create score element
    let mei_score = convert_score_content(score, ctx)?;
    mdiv.children.push(MdivChild::Score(Box::new(mei_score)));

    Ok(mdiv)
}

/// Convert MusicXML score content to MEI score element.
pub fn convert_score_content(
    score: &ScorePartwise,
    ctx: &mut ConversionContext,
) -> ConversionResult<Score> {
    let mut mei_score = Score::default();

    // Create scoreDef with staffGrp from part-list
    let score_def = convert_score_def(score, ctx)?;
    mei_score
        .children
        .push(ScoreChild::ScoreDef(Box::new(score_def)));

    // Create section containing measures
    let section = convert_section(score, ctx)?;
    mei_score
        .children
        .push(ScoreChild::Section(Box::new(section)));

    Ok(mei_score)
}

/// Convert MusicXML measures to MEI section.
pub fn convert_section(
    score: &ScorePartwise,
    ctx: &mut ConversionContext,
) -> ConversionResult<Section> {
    let mut section = Section::default();

    // Get the number of measures from the first part (all parts should have same count)
    let measure_count = score.parts.first().map(|p| p.measures.len()).unwrap_or(0);

    // Process measures
    // In MEI, measures contain staves; in MusicXML, parts contain measures.
    // We need to transpose this: for each measure number, collect content from all parts.
    for measure_idx in 0..measure_count {
        let mei_measure = convert_measure(score, measure_idx, ctx)?;
        section
            .children
            .push(SectionChild::Measure(Box::new(mei_measure)));
    }

    Ok(section)
}

/// Convert a MusicXML measure (from all parts) to MEI measure.
///
/// Converts MusicXML measure attributes to MEI:
/// - `number` → MEI `@n` (measure number/label)
/// - `implicit="yes"` → MEI `@metcon="false"` (incomplete/pickup measure)
/// - `width` → MEI `@width` (measure width for layout)
/// - `id` → MEI `xml:id` (element ID)
/// - `non_controlling="yes"` → MEI `@control="false"` (non-controlling barline)
pub fn convert_measure(
    score: &ScorePartwise,
    measure_idx: usize,
    ctx: &mut ConversionContext,
) -> ConversionResult<tusk_model::elements::Measure> {
    use tusk_model::elements::Measure;

    let mut mei_measure = Measure::default();

    // Get measure from first part to extract common attributes
    if let Some(first_part) = score.parts.first()
        && let Some(musicxml_measure) = first_part.measures.get(measure_idx)
    {
        // Convert measure attributes
        convert_measure_attributes(musicxml_measure, &mut mei_measure, ctx);
        ctx.set_measure(&musicxml_measure.number);
    }

    // Create a staff element for each part
    for (part_idx, part) in score.parts.iter().enumerate() {
        let staff_number = (part_idx + 1) as u32;
        ctx.set_part(&part.id);
        ctx.set_staff(staff_number);

        if let Some(musicxml_measure) = part.measures.get(measure_idx) {
            let staff = convert_staff(musicxml_measure, staff_number, ctx)?;
            mei_measure
                .children
                .push(MeasureChild::Staff(Box::new(staff)));

            // Convert directions to control events
            convert_measure_directions(musicxml_measure, &mut mei_measure, ctx)?;
        }
    }

    Ok(mei_measure)
}

/// Convert MusicXML directions in a measure to MEI control events.
///
/// Processes all Direction elements in the measure content and converts them
/// to the appropriate MEI control events (dynam, hairpin, tempo, dir).
fn convert_measure_directions(
    musicxml_measure: &tusk_musicxml::model::elements::Measure,
    mei_measure: &mut tusk_model::elements::Measure,
    ctx: &mut ConversionContext,
) -> ConversionResult<()> {
    use tusk_musicxml::model::elements::MeasureContent;

    for content in &musicxml_measure.content {
        if let MeasureContent::Direction(direction) = content {
            let results = convert_direction(direction, ctx)?;

            for result in results {
                match result {
                    DirectionConversionResult::Dynam(dynam) => {
                        mei_measure
                            .children
                            .push(MeasureChild::Dynam(Box::new(dynam)));
                    }
                    DirectionConversionResult::Hairpin(hairpin) => {
                        mei_measure
                            .children
                            .push(MeasureChild::Hairpin(Box::new(hairpin)));
                    }
                    DirectionConversionResult::Tempo(tempo) => {
                        mei_measure
                            .children
                            .push(MeasureChild::Tempo(Box::new(tempo)));
                    }
                    DirectionConversionResult::Dir(dir) => {
                        mei_measure.children.push(MeasureChild::Dir(Box::new(dir)));
                    }
                }
            }
        }
    }

    Ok(())
}

/// Convert MusicXML measure attributes to MEI measure attributes.
///
/// Maps:
/// - `number` → `@n` (measure number/label)
/// - `implicit="yes"` → `@metcon="false"` (metrically incomplete)
/// - `width` → `@width` (measure width)
/// - `id` → `xml:id` (element ID)
/// - `non_controlling="yes"` → `@control="false"` (non-controlling barline)
fn convert_measure_attributes(
    musicxml_measure: &tusk_musicxml::model::elements::Measure,
    mei_measure: &mut tusk_model::elements::Measure,
    ctx: &mut ConversionContext,
) {
    use tusk_musicxml::model::data::YesNo;

    // Measure number → @n
    mei_measure.common.n = Some(DataWord::from(musicxml_measure.number.clone()));

    // implicit="yes" → metcon="false" (metrically non-conformant / pickup measure)
    // In MusicXML, implicit="yes" means the measure doesn't count in measure numbering
    // In MEI, metcon="false" means the measure content doesn't conform to the prevailing meter
    if let Some(YesNo::Yes) = musicxml_measure.implicit {
        mei_measure.measure_log.metcon = Some(DataBoolean::False);
    }

    // width → @width (in tenths, convert to MEI measurement format)
    // MusicXML width is in tenths; we'll preserve the value with "vu" unit
    if let Some(width) = musicxml_measure.width {
        // Convert to string with virtual units (vu)
        mei_measure.measure_vis.width = Some(DataMeasurementunsigned::from(format!("{}vu", width)));
    }

    // id → xml:id (with mapping)
    if let Some(ref id) = musicxml_measure.id {
        let mei_id = ctx.generate_id_with_suffix("measure");
        ctx.map_id(id, mei_id.clone());
        mei_measure.common.xml_id = Some(mei_id);
    }

    // non_controlling="yes" → control="false" (barline is not controlling)
    // In MusicXML, non-controlling measures in multi-rest regions have non_controlling="yes"
    // In MEI, control="false" means the right bar line doesn't indicate alignment across parts
    if let Some(YesNo::Yes) = musicxml_measure.non_controlling {
        mei_measure.measure_log.control = Some(DataBoolean::False);
    }
}

/// Convert MusicXML measure content to MEI staff.
pub fn convert_staff(
    _measure: &tusk_musicxml::model::elements::Measure,
    staff_number: u32,
    ctx: &mut ConversionContext,
) -> ConversionResult<tusk_model::elements::Staff> {
    use tusk_model::elements::Staff;

    let mut staff = Staff::default();
    // Set staff number using n_integer.n (u64)
    staff.n_integer.n = Some(staff_number as u64);

    // Create a layer for the content
    // Note: Full measure content conversion will be implemented in subsequent tasks
    let layer = convert_layer(_measure, 1, ctx)?;
    staff.children.push(StaffChild::Layer(Box::new(layer)));

    Ok(staff)
}

/// Convert MusicXML measure content to MEI layer.
pub fn convert_layer(
    measure: &tusk_musicxml::model::elements::Measure,
    layer_number: u32,
    ctx: &mut ConversionContext,
) -> ConversionResult<tusk_model::elements::Layer> {
    use crate::musicxml_to_mei::process_attributes;
    use tusk_model::elements::Layer;
    use tusk_musicxml::model::elements::MeasureContent;

    let mut layer = Layer::default();
    // Set layer number using n_integer.n (u64)
    layer.n_integer.n = Some(layer_number as u64);

    ctx.set_layer(layer_number);
    ctx.reset_beat_position();

    // Collect all notes from the measure content for chord detection
    let notes: Vec<&tusk_musicxml::model::note::Note> = measure
        .content
        .iter()
        .filter_map(|c| match c {
            MeasureContent::Note(note) => Some(note.as_ref()),
            _ => None,
        })
        .collect();

    // Track which notes we've processed (for chord grouping)
    let mut processed_note_indices: std::collections::HashSet<usize> =
        std::collections::HashSet::new();

    // Process measure content
    let mut note_index = 0;
    for content in &measure.content {
        match content {
            MeasureContent::Note(note) => {
                // Find the index of this note in our notes vec
                let current_note_index = notes
                    .iter()
                    .position(|n| std::ptr::eq(*n, note.as_ref()))
                    .unwrap_or(note_index);
                note_index += 1;

                // Skip if already processed as part of a chord
                if processed_note_indices.contains(&current_note_index) {
                    continue;
                }

                // Skip chord notes (they are processed with their root note)
                if note.is_chord() {
                    continue;
                }

                // Handle rests
                if note.is_rest() {
                    if is_measure_rest(note) {
                        // Measure rest → MEI mRest
                        let mei_mrest = convert_measure_rest(note, ctx)?;
                        layer.children.push(LayerChild::MRest(Box::new(mei_mrest)));
                    } else {
                        // Regular rest → MEI rest
                        let mei_rest = convert_rest(note, ctx)?;
                        layer.children.push(LayerChild::Rest(Box::new(mei_rest)));
                    }

                    // Advance beat position for rests
                    if let Some(duration) = note.duration {
                        ctx.advance_beat_position(duration);
                    }
                    processed_note_indices.insert(current_note_index);
                    continue;
                }

                // Check if this note is followed by chord notes
                let mut chord_notes: Vec<tusk_musicxml::model::note::Note> =
                    vec![note.as_ref().clone()];
                processed_note_indices.insert(current_note_index);

                // Look ahead for chord notes
                for (i, following_note) in notes.iter().enumerate().skip(current_note_index + 1) {
                    if following_note.is_chord() && !following_note.is_rest() {
                        chord_notes.push((*following_note).clone());
                        processed_note_indices.insert(i);
                    } else {
                        // First non-chord note ends the chord group
                        break;
                    }
                }

                if chord_notes.len() > 1 {
                    // Convert as chord
                    let mei_chord = convert_chord(&chord_notes, ctx)?;
                    layer.children.push(LayerChild::Chord(Box::new(mei_chord)));
                } else {
                    // Convert as single note
                    let mei_note = convert_note(note, ctx)?;
                    layer.children.push(LayerChild::Note(Box::new(mei_note)));
                }

                // Advance beat position if not a grace note
                if !note.is_grace()
                    && let Some(duration) = note.duration
                {
                    ctx.advance_beat_position(duration);
                }
            }
            MeasureContent::Attributes(attrs) => {
                // Process attributes: divisions, key signature, time signature, clef
                // Note: For now, we only update the context state.
                // The initial staffDef is updated separately in convert_score_def.
                // Mid-measure changes would need staffDef change elements (future work).
                process_attributes(attrs, ctx, None);
            }
            MeasureContent::Backup(backup) => {
                // Move beat position backward
                ctx.advance_beat_position(-backup.duration);
            }
            MeasureContent::Forward(forward) => {
                // Move beat position forward
                ctx.advance_beat_position(forward.duration);
            }
            // Other content types will be handled in subsequent tasks
            _ => {}
        }
    }

    Ok(layer)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::context::ConversionDirection;
    use crate::musicxml_to_mei::convert_staff_grp;
    use tusk_model::elements::{
        LabelAbbrChild, LabelChild, MdivChild, StaffDefChild, StaffGrpChild,
    };
    use tusk_musicxml::model::elements::{Part, PartList, PartListItem, PartName, ScorePart};

    /// Helper to create a ScorePart with the given id and name.
    fn make_score_part(id: &str, name: &str) -> ScorePart {
        ScorePart {
            id: id.to_string(),
            identification: None,
            part_links: vec![],
            part_name: PartName {
                value: name.to_string(),
                ..Default::default()
            },
            part_name_display: None,
            part_abbreviation: None,
            part_abbreviation_display: None,
            groups: vec![],
            score_instruments: vec![],
            players: vec![],
            midi_assignments: vec![],
        }
    }

    // ============================================================================
    // Score Structure Tests
    // ============================================================================

    #[test]
    fn convert_score_creates_body_with_mdiv() {
        let score = ScorePartwise::default();
        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);

        let body = convert_body(&score, &mut ctx).expect("conversion should succeed");

        assert_eq!(body.children.len(), 1);
        assert!(matches!(&body.children[0], BodyChild::Mdiv(_)));
    }

    #[test]
    fn convert_mdiv_contains_score() {
        let score = ScorePartwise::default();
        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);

        let mdiv = convert_mdiv(&score, &mut ctx).expect("conversion should succeed");

        assert_eq!(mdiv.children.len(), 1);
        assert!(matches!(&mdiv.children[0], MdivChild::Score(_)));
    }

    #[test]
    fn convert_score_content_has_score_def_and_section() {
        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_score = convert_score_content(&score, &mut ctx).expect("conversion should succeed");

        // Should have scoreDef followed by section
        assert!(mei_score.children.len() >= 2);
        assert!(matches!(&mei_score.children[0], ScoreChild::ScoreDef(_)));
        assert!(matches!(&mei_score.children[1], ScoreChild::Section(_)));
    }

    // ============================================================================
    // Measure Conversion Tests
    // ============================================================================

    #[test]
    fn convert_section_creates_measures() {
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };
        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![Measure::new("1"), Measure::new("2")],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let section = convert_section(&score, &mut ctx).expect("conversion should succeed");

        // Should have 2 measures
        let measure_count = section
            .children
            .iter()
            .filter(|c| matches!(c, SectionChild::Measure(_)))
            .count();
        assert_eq!(measure_count, 2);
    }

    #[test]
    fn convert_measure_sets_measure_number() {
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };
        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![Measure::new("42")],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // Check measure number is set via common.n
        assert!(mei_measure.common.n.is_some());
        let n = mei_measure.common.n.as_ref().unwrap();
        assert_eq!(n.0, "42");
    }

    // ============================================================================
    // Measure Attribute Conversion Tests
    // ============================================================================

    #[test]
    fn convert_measure_implicit_yes_sets_metcon_false() {
        use tusk_musicxml::model::data::YesNo;
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Create a pickup measure (implicit="yes")
        let mut pickup_measure = Measure::new("0");
        pickup_measure.implicit = Some(YesNo::Yes);

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![pickup_measure],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // implicit="yes" → metcon="false"
        assert_eq!(mei_measure.measure_log.metcon, Some(DataBoolean::False));
    }

    #[test]
    fn convert_measure_implicit_no_does_not_set_metcon() {
        use tusk_musicxml::model::data::YesNo;
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Regular measure (implicit="no" or absent)
        let mut regular_measure = Measure::new("1");
        regular_measure.implicit = Some(YesNo::No);

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![regular_measure],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // implicit="no" → metcon not set (defaults to true)
        assert!(mei_measure.measure_log.metcon.is_none());
    }

    #[test]
    fn convert_measure_width_sets_width_attribute() {
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Measure with explicit width
        let mut measure_with_width = Measure::new("1");
        measure_with_width.width = Some(150.5);

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![measure_with_width],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // width → @width with virtual units
        assert!(mei_measure.measure_vis.width.is_some());
        let width = mei_measure.measure_vis.width.as_ref().unwrap();
        assert_eq!(width.0, "150.5vu");
    }

    #[test]
    fn convert_measure_id_sets_xml_id_and_maps() {
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Measure with explicit ID
        let mut measure_with_id = Measure::new("1");
        measure_with_id.id = Some("measure1".to_string());

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![measure_with_id],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // id → xml:id (generated)
        assert!(mei_measure.common.xml_id.is_some());

        // ID should be mapped
        let mei_id = ctx.get_mei_id("measure1");
        assert!(mei_id.is_some());
        assert_eq!(mei_measure.common.xml_id.as_deref(), mei_id);
    }

    #[test]
    fn convert_measure_non_controlling_yes_sets_control_false() {
        use tusk_musicxml::model::data::YesNo;
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Non-controlling measure (in multi-rest region)
        let mut non_controlling_measure = Measure::new("2");
        non_controlling_measure.non_controlling = Some(YesNo::Yes);

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![non_controlling_measure],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // non_controlling="yes" → control="false"
        assert_eq!(mei_measure.measure_log.control, Some(DataBoolean::False));
    }

    #[test]
    fn convert_measure_no_optional_attributes() {
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Basic measure with only required number
        let basic_measure = Measure::new("1");

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![basic_measure],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // Only @n should be set, optional attributes should be None
        assert!(mei_measure.common.n.is_some());
        assert_eq!(mei_measure.common.n.as_ref().unwrap().0, "1");
        assert!(mei_measure.measure_log.metcon.is_none());
        assert!(mei_measure.measure_vis.width.is_none());
        assert!(mei_measure.common.xml_id.is_none());
        assert!(mei_measure.measure_log.control.is_none());
    }

    #[test]
    fn convert_measure_all_attributes_combined() {
        use tusk_musicxml::model::data::YesNo;
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };

        // Measure with all optional attributes
        let full_measure = Measure {
            number: "0".to_string(),
            implicit: Some(YesNo::Yes),
            non_controlling: Some(YesNo::Yes),
            width: Some(200.0),
            id: Some("m0".to_string()),
            content: vec![],
        };

        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![full_measure],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let mei_measure = convert_measure(&score, 0, &mut ctx).expect("conversion should succeed");

        // All attributes should be converted
        assert_eq!(mei_measure.common.n.as_ref().unwrap().0, "0");
        assert_eq!(mei_measure.measure_log.metcon, Some(DataBoolean::False));
        assert_eq!(mei_measure.measure_log.control, Some(DataBoolean::False));
        assert_eq!(mei_measure.measure_vis.width.as_ref().unwrap().0, "200vu");
        assert!(mei_measure.common.xml_id.is_some());
        assert!(ctx.get_mei_id("m0").is_some());
    }

    // ============================================================================
    // Context Tracking Tests
    // ============================================================================

    #[test]
    fn conversion_tracks_current_position() {
        use crate::musicxml_to_mei::convert_score_with_context;
        use tusk_musicxml::model::elements::Measure;

        let mut score = ScorePartwise::default();
        score.part_list = PartList {
            items: vec![PartListItem::ScorePart(Box::new(make_score_part(
                "P1", "Piano",
            )))],
        };
        score.parts = vec![Part {
            id: "P1".to_string(),
            measures: vec![Measure::new("5")],
        }];

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        let _mei = convert_score_with_context(&score, &mut ctx).expect("conversion should succeed");

        // After conversion, context should track last processed position
        assert_eq!(ctx.position().part_id.as_deref(), Some("P1"));
        assert_eq!(ctx.position().measure_number.as_deref(), Some("5"));
    }

    // ============================================================================
    // Layer Integration Tests
    // ============================================================================

    #[test]
    fn convert_layer_with_notes_creates_note_children() {
        use tusk_musicxml::model::data::Step;
        use tusk_musicxml::model::elements::{Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Pitch};

        let mut measure = Measure::new("1");

        // Add a note
        let mut note = Note::pitched(Pitch::new(Step::C, 4), 4.0);
        note.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Should have one note child
        assert_eq!(layer.children.len(), 1);
        assert!(matches!(layer.children[0], LayerChild::Note(_)));
    }

    #[test]
    fn convert_layer_with_rests_creates_rest_children() {
        use tusk_musicxml::model::elements::{Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Rest};

        let mut measure = Measure::new("1");

        // Add a rest
        let mut note = Note::rest(Rest::new(), 4.0);
        note.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Should have one rest child
        assert_eq!(layer.children.len(), 1);
        assert!(matches!(layer.children[0], LayerChild::Rest(_)));
    }

    #[test]
    fn convert_layer_with_measure_rest_creates_mrest_child() {
        use tusk_musicxml::model::data::YesNo;
        use tusk_musicxml::model::elements::{Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, Rest};

        let mut measure = Measure::new("1");

        // Add a measure rest
        let mut rest = Rest::new();
        rest.measure = Some(YesNo::Yes);
        let note = Note::rest(rest, 16.0);
        measure.content.push(MeasureContent::Note(Box::new(note)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Should have one mRest child
        assert_eq!(layer.children.len(), 1);
        assert!(matches!(layer.children[0], LayerChild::MRest(_)));
    }

    #[test]
    fn convert_layer_advances_beat_position_for_rest() {
        use tusk_musicxml::model::elements::{Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Rest};

        let mut measure = Measure::new("1");

        // Add a rest with duration
        let mut note = Note::rest(Rest::new(), 4.0);
        note.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let _layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Beat position should have advanced by the rest duration
        assert_eq!(ctx.beat_position(), 4.0);
    }

    #[test]
    fn convert_layer_with_chord() {
        use tusk_musicxml::model::data::Step;
        use tusk_musicxml::model::elements::{Empty, Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Pitch};

        let mut measure = Measure::new("1");

        // Add a chord (C4, E4)
        let mut note1 = Note::pitched(Pitch::new(Step::C, 4), 4.0);
        note1.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note1)));

        let mut note2 = Note::pitched(Pitch::new(Step::E, 4), 4.0);
        note2.chord = Some(Empty);
        note2.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note2)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Should have one chord child (not two separate notes)
        assert_eq!(layer.children.len(), 1);
        assert!(matches!(layer.children[0], LayerChild::Chord(_)));
    }

    #[test]
    fn convert_layer_with_chord_advances_beat_position() {
        use tusk_musicxml::model::data::Step;
        use tusk_musicxml::model::elements::{Empty, Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Pitch};

        let mut measure = Measure::new("1");

        // Add a chord (C4, E4) with duration 4
        let mut note1 = Note::pitched(Pitch::new(Step::C, 4), 4.0);
        note1.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note1)));

        let mut note2 = Note::pitched(Pitch::new(Step::E, 4), 4.0);
        note2.chord = Some(Empty);
        note2.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note2)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let _layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Beat position should have advanced by the chord duration (once, not twice)
        assert_eq!(ctx.beat_position(), 4.0);
    }

    #[test]
    fn convert_layer_mixed_notes_and_chords() {
        use tusk_musicxml::model::data::Step;
        use tusk_musicxml::model::elements::{Empty, Measure, MeasureContent};
        use tusk_musicxml::model::note::{Note, NoteType, NoteTypeValue, Pitch};

        let mut measure = Measure::new("1");

        // Single note
        let mut note1 = Note::pitched(Pitch::new(Step::C, 4), 4.0);
        note1.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note1)));

        // Chord (E4, G4)
        let mut note2 = Note::pitched(Pitch::new(Step::E, 4), 4.0);
        note2.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note2)));

        let mut note3 = Note::pitched(Pitch::new(Step::G, 4), 4.0);
        note3.chord = Some(Empty);
        note3.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note3)));

        // Another single note
        let mut note4 = Note::pitched(Pitch::new(Step::A, 4), 4.0);
        note4.note_type = Some(NoteType::new(NoteTypeValue::Quarter));
        measure.content.push(MeasureContent::Note(Box::new(note4)));

        let mut ctx = ConversionContext::new(ConversionDirection::MusicXmlToMei);
        ctx.set_divisions(4.0);

        let layer = convert_layer(&measure, 1, &mut ctx).expect("conversion should succeed");

        // Should have: Note, Chord, Note
        assert_eq!(layer.children.len(), 3);
        assert!(matches!(layer.children[0], LayerChild::Note(_)));
        assert!(matches!(layer.children[1], LayerChild::Chord(_)));
        assert!(matches!(layer.children[2], LayerChild::Note(_)));
    }
}
